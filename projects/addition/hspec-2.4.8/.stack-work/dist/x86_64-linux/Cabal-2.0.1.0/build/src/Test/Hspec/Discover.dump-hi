
==================== FINAL INTERFACE ====================
2018-02-12 23:17:45.4121 UTC

interface hspec-2.4.8-AD8oV31xXDiFndrFhOZAG:Test.Hspec.Discover 8022
  interface hash: 92cf426ca3b05a7e2a68a2329b5348c4
  ABI hash: 4f0a0df78c483de177e9b6a1d7c6e757
  export-list hash: 84ce427d5c4d50eb8476784a042fb0a6
  orphan hash: fa4615a7f2530aea97f052e606c4627b
  flag hash: cad7605989c6b62260695efc28df29ff
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Either.either
  Data.Foldable.all
  Data.Foldable.and
  Data.Foldable.any
  Data.Foldable.concat
  Data.Foldable.concatMap
  Data.Foldable.mapM_
  Data.Foldable.notElem
  Data.Foldable.or
  Data.Foldable.sequence_
  Data.Functor.<$>
  Data.Maybe.maybe
  Data.OldList.lines
  Data.OldList.unlines
  Data.OldList.unwords
  Data.OldList.words
  Data.Tuple.curry
  Data.Tuple.fst
  Data.Tuple.snd
  Data.Tuple.uncurry
  GHC.Base.$!
  GHC.Base.++
  GHC.Base..
  GHC.Base.=<<
  GHC.Base.asTypeOf
  GHC.Base.const
  GHC.Base.flip
  GHC.Base.id
  GHC.Base.map
  GHC.Base.otherwise
  GHC.Base.until
  GHC.Err.error
  GHC.Err.errorWithoutStackTrace
  GHC.Err.undefined
  GHC.IO.Exception.ioError
  GHC.IO.Exception.userError
  GHC.List.!!
  GHC.List.break
  GHC.List.cycle
  GHC.List.drop
  GHC.List.dropWhile
  GHC.List.filter
  GHC.List.head
  GHC.List.init
  GHC.List.iterate
  GHC.List.last
  GHC.List.lookup
  GHC.List.repeat
  GHC.List.replicate
  GHC.List.reverse
  GHC.List.scanl
  GHC.List.scanl1
  GHC.List.scanr
  GHC.List.scanr1
  GHC.List.span
  GHC.List.splitAt
  GHC.List.tail
  GHC.List.take
  GHC.List.takeWhile
  GHC.List.unzip
  GHC.List.unzip3
  GHC.List.zip
  GHC.List.zip3
  GHC.List.zipWith
  GHC.List.zipWith3
  GHC.Num.subtract
  GHC.Read.lex
  GHC.Read.readParen
  GHC.Real.^
  GHC.Real.^^
  GHC.Real.even
  GHC.Real.fromIntegral
  GHC.Real.gcd
  GHC.Real.lcm
  GHC.Real.odd
  GHC.Real.realToFrac
  GHC.Show.showChar
  GHC.Show.showParen
  GHC.Show.showString
  GHC.Show.shows
  System.IO.appendFile
  System.IO.getChar
  System.IO.getContents
  System.IO.getLine
  System.IO.interact
  System.IO.print
  System.IO.putChar
  System.IO.putStr
  System.IO.putStrLn
  System.IO.readFile
  System.IO.readIO
  System.IO.readLn
  System.IO.writeFile
  Text.Read.read
  Text.Read.reads
  GHC.Classes.&&
  GHC.Classes.not
  GHC.Classes.||
  Test.Hspec.Discover.hspecWithFormatter
  Test.Hspec.Discover.postProcessSpec
  Test.Hspec.Core.Runner.hspec
  Test.Hspec.Core.Spec.describe
  GHC.Base.$
  GHC.Prim.seq
  Data.Either.Either{Data.Either.Left Data.Either.Right}
  Data.Foldable.Foldable{Data.Foldable.elem Data.Foldable.foldMap Data.Foldable.foldl Data.Foldable.foldl1 Data.Foldable.foldr Data.Foldable.foldr1 Data.Foldable.length Data.Foldable.maximum Data.Foldable.minimum Data.Foldable.null Data.Foldable.product Data.Foldable.sum}
  Data.Traversable.Traversable{Data.Traversable.sequence Data.Traversable.sequenceA Data.Traversable.traverse}
  GHC.Base.Applicative{GHC.Base.*> GHC.Base.<* GHC.Base.<*> GHC.Base.pure}
  GHC.Base.Functor{GHC.Base.<$ GHC.Base.fmap}
  GHC.Base.Monad{GHC.Base.>> GHC.Base.>>= GHC.Base.fail GHC.Base.return}
  GHC.Base.Monoid{GHC.Base.mappend GHC.Base.mconcat GHC.Base.mempty}
  GHC.Base.String
  GHC.Enum.Bounded{GHC.Enum.maxBound GHC.Enum.minBound}
  GHC.Enum.Enum{GHC.Enum.enumFrom GHC.Enum.enumFromThen GHC.Enum.enumFromThenTo GHC.Enum.enumFromTo GHC.Enum.fromEnum GHC.Enum.pred GHC.Enum.succ GHC.Enum.toEnum}
  GHC.Float.Floating{GHC.Float.** GHC.Float.acos GHC.Float.acosh GHC.Float.asin GHC.Float.asinh GHC.Float.atan GHC.Float.atanh GHC.Float.cos GHC.Float.cosh GHC.Float.exp GHC.Float.log GHC.Float.logBase GHC.Float.pi GHC.Float.sin GHC.Float.sinh GHC.Float.sqrt GHC.Float.tan GHC.Float.tanh}
  GHC.Float.RealFloat{GHC.Float.atan2 GHC.Float.decodeFloat GHC.Float.encodeFloat GHC.Float.exponent GHC.Float.floatDigits GHC.Float.floatRadix GHC.Float.floatRange GHC.Float.isDenormalized GHC.Float.isIEEE GHC.Float.isInfinite GHC.Float.isNaN GHC.Float.isNegativeZero GHC.Float.scaleFloat GHC.Float.significand}
  GHC.IO.FilePath
  GHC.IO.Exception.IOError
  GHC.Num.Num{GHC.Num.* GHC.Num.+ GHC.Num.- GHC.Num.abs GHC.Num.fromInteger GHC.Num.negate GHC.Num.signum}
  GHC.Read.Read{GHC.Read.readList GHC.Read.readsPrec}
  GHC.Real.Fractional{GHC.Real./ GHC.Real.fromRational GHC.Real.recip}
  GHC.Real.Integral{GHC.Real.div GHC.Real.divMod GHC.Real.mod GHC.Real.quot GHC.Real.quotRem GHC.Real.rem GHC.Real.toInteger}
  GHC.Real.Rational
  GHC.Real.Real{GHC.Real.toRational}
  GHC.Real.RealFrac{GHC.Real.ceiling GHC.Real.floor GHC.Real.properFraction GHC.Real.round GHC.Real.truncate}
  GHC.Show.Show{GHC.Show.show GHC.Show.showList GHC.Show.showsPrec}
  GHC.Show.ShowS
  Text.ParserCombinators.ReadP.ReadS
  GHC.Classes.Eq{GHC.Classes./= GHC.Classes.==}
  GHC.Classes.Ord{GHC.Classes.< GHC.Classes.<= GHC.Classes.> GHC.Classes.>= GHC.Classes.compare GHC.Classes.max GHC.Classes.min}
  GHC.Types.IO
  GHC.Types.Ordering{GHC.Types.EQ GHC.Types.GT GHC.Types.LT}
  Test.Hspec.Discover.IsFormatter{Test.Hspec.Discover.toFormatter}
  Test.Hspec.Core.Spec.Monad.Spec
  GHC.Integer.Type.Integer
  GHC.Base.Maybe{GHC.Base.Just GHC.Base.Nothing}
  GHC.Types.Bool{GHC.Types.False GHC.Types.True}
  GHC.Types.Char
  GHC.Types.Double
  GHC.Types.Float
  GHC.Types.Int
  GHC.Types.Word
module dependencies: Test.Hspec.Formatters
package dependencies: HUnit-1.6.0.0 QuickCheck-2.10.1
                      ansi-terminal-0.7.1.1 array-0.5.2.0 base-4.10.1.0 call-stack-0.1.0
                      colour-2.3.4 containers-0.5.10.2 deepseq-1.4.3.0 directory-1.3.0.2
                      filepath-1.4.1.2 ghc-boot-th-8.2.2 ghc-prim-0.5.1.1
                      hspec-core-2.4.8 hspec-expectations-0.8.2 integer-gmp-1.0.1.0
                      pretty-1.1.3.3 primitive-0.6.3.0 quickcheck-io-0.2.0 random-1.1
                      setenv-0.1.1.3 stm-2.4.5.0 template-haskell-2.12.0.0 tf-random-0.5
                      time-1.8.0.2 transformers-0.5.2.0 unix-2.7.2.2
orphans: colour-2.3.4:Data.Colour
         quickcheck-io-0.2.0:Test.QuickCheck.IO
         transformers-0.5.2.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         stm-2.4.5.0:Control.Monad.STM base-4.10.1.0:GHC.Float
         base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Complex base-4.10.1.0:Data.Either
                         base-4.10.1.0:Data.Functor.Compose base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats containers-0.5.10.2:Data.IntMap.Internal
                         containers-0.5.10.2:Data.IntSet.Internal
                         containers-0.5.10.2:Data.Map.Internal
                         containers-0.5.10.2:Data.Sequence.Internal
                         containers-0.5.10.2:Data.Set.Internal
                         ghc-boot-th-8.2.2:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.2.2:GHC.LanguageExtensions.Type
                         hspec-core-2.4.8:Test.Hspec.Core.Example
                         pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         template-haskell-2.12.0.0:Language.Haskell.TH.Syntax
import  -/  base-4.10.1.0:Control.Applicative 99577a9c463ffe4790a1d37547a345bd
import  -/  base-4.10.1.0:Data.Either d7dae5d9bf298dee616e465c14b5d60e
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.Functor 2ffda4f936b8f474394d93205750aff3
import  -/  base-4.10.1.0:Data.List 4ab7fa2a1b87502b23af891a384f0506
import  -/  base-4.10.1.0:Data.Maybe 07738c5485acb328136bb15596f8b845
import  -/  base-4.10.1.0:Data.OldList 555420b092ca8cf0a8f9666bc0e07dcf
import  -/  base-4.10.1.0:Data.Traversable 60ea7c2973e63de7d08d5d0269f96e67
import  -/  base-4.10.1.0:Data.Tuple 8fa1305aa5032ea35e2a54fa5f1e78f9
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Enum 5a1ba50c23f92f669e01f8955f202337
import  -/  base-4.10.1.0:GHC.Err 514b3a24b22e9d7d731c2d0d02d10842
import  -/  base-4.10.1.0:GHC.Float 28e3bf9e258278ac8084e9cab43fd542
import  -/  base-4.10.1.0:GHC.IO e261d8b68ccf81a359626fa520b57d1d
import  -/  base-4.10.1.0:GHC.IO.Exception c72758923693d771268bed5d3d52443d
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:System.IO 6e5bb580370d8d71dc5888f723cea4b4
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  Test.Hspec.Formatters 43b11c11023f0256d08aae32233b8454
  exports: 75303977a672727b0cf8c109abd46605
import  -/  hspec-core-2.4.8:Test.Hspec.Core.Example 52762472c8e68fc75b6cce4f11dab2ba
import  -/  hspec-core-2.4.8:Test.Hspec.Core.Formatters.Monad 59867745c1a29d041a98d83bee4687c9
import  -/  hspec-core-2.4.8:Test.Hspec.Core.Options aad85d664d2c71340c444a31b9b2255e
import  -/  hspec-core-2.4.8:Test.Hspec.Core.Runner 44826efc6dc36985445ec1d2fa2204dc
import  -/  hspec-core-2.4.8:Test.Hspec.Core.Spec 1ff1f1350ee0955de60346298ce321a7
import  -/  hspec-core-2.4.8:Test.Hspec.Core.Spec.Monad e92f54848c64cf25cef2cffb1d44bd57
import  -/  hspec-core-2.4.8:Test.Hspec.Core.Tree e75f3b0361736ed13fff4f23548847c6
import  -/  hspec-core-2.4.8:Test.Hspec.Core.Util f20a4f5b35cb443fd94232343f0e6f7b
import  -/  integer-gmp-1.0.1.0:GHC.Integer.Type 5fa81108482c33b62ec3ac7464eece96
import  -/  transformers-0.5.2.0:Control.Monad.Trans.State 06d668f8d9bf74ff2fc8ef4841fb8eef
import  -/  transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 1a80bdb936666c1b8faf2f03f91a48cc
67c197212c792d0a88a4f6cde81cc919
  $fIsFormatterFormatter ::
    Test.Hspec.Discover.IsFormatter
      Test.Hspec.Core.Formatters.Monad.Formatter
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                (GHC.Base.$fApplicativeIO4
                   @ Test.Hspec.Core.Formatters.Monad.Formatter)
                  `cast`
                (Trans
                     (<Test.Hspec.Core.Formatters.Monad.Formatter>_R
                      ->_R Sym (GHC.Types.N:IO[0]
                                    <Test.Hspec.Core.Formatters.Monad.Formatter>_R))
                     (Sym (Test.Hspec.Discover.N:IsFormatter[0]
                               <Test.Hspec.Core.Formatters.Monad.Formatter>_N))) -}
67c197212c792d0a88a4f6cde81cc919
  $fIsFormatterIO ::
    Test.Hspec.Discover.IsFormatter
      (GHC.Types.IO Test.Hspec.Core.Formatters.Monad.Formatter)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                (GHC.Base.id
                   @ (GHC.Types.IO Test.Hspec.Core.Formatters.Monad.Formatter))
                  `cast`
                (Sym (Test.Hspec.Discover.N:IsFormatter[0]
                          <GHC.Types.IO Test.Hspec.Core.Formatters.Monad.Formatter>_N)) -}
12e5f5076695f4e83a23fa6d6f05ea12
  $s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s Data.Functor.Identity.Identity)
                  (Test.Hspec.Discover.$s$fApplicativeStateT_$s$fFunctorStateT @ s)
                  (Test.Hspec.Discover.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
                     @ s)
                  (Test.Hspec.Discover.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
                     @ s)
                  (Control.Monad.Trans.State.Lazy.$fAlternativeStateT2
                     @ Data.Functor.Identity.Identity
                     @ s
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Functor.Identity.Identity>_R <c>_N))
                  (Control.Monad.Trans.State.Lazy.$fApplicativeStateT1
                     @ Data.Functor.Identity.Identity
                     @ s
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s Data.Functor.Identity.Identity a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Functor.Identity.Identity>_R <b>_N))
                  (\ @ a
                     @ b
                     (x :: Control.Monad.Trans.State.Lazy.StateT
                             s Data.Functor.Identity.Identity a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               s Data.Functor.Identity.Identity b)
                     (eta1 :: s) ->
                   let {
                     ds :: Data.Functor.Identity.Identity (a, s)
                     = x `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                         eta1
                   } in
                   (case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(a, s)>_R) of wild { (,) a1 s' ->
                    a1 },
                    case (eta
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)
                            (case ds
                                    `cast`
                                  (Data.Functor.Identity.N:Identity[0]
                                       <(a, s)>_R) of wild { (,) a1 s' ->
                             s' }))
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(b, s)>_R) of wild { (,) x1 s'' ->
                    s'' })
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0] <(a, s)>_R)))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s Data.Functor.Identity.Identity a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Functor.Identity.Identity>_R <a>_N)) -}
bf7290a650a24d5b16b3448988e68187
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s Data.Functor.Identity.Identity (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*C1(U),1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Lazy.StateT
                             s Data.Functor.Identity.Identity a)
                   (s1 :: s) ->
                 let {
                   ds2 :: Data.Functor.Identity.Identity (a -> b, s)
                   = ds
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Data.Functor.Identity.Identity>_R <a -> b>_N)
                       s1
                 } in
                 let {
                   ds3 :: Data.Functor.Identity.Identity (a, s)
                   = ds1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                       (case ds2
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <(a -> b, s)>_R) of wild { (,) f2 s' ->
                        s' })
                 } in
                 (case ds2
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(a -> b, s)>_R) of wild { (,) f2 s' ->
                  f2
                    (case ds3
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a, s)>_R) of wild1 { (,) x s'' ->
                     x }) },
                  case ds3
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(a, s)>_R) of wild { (,) x s'' ->
                  s'' })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0] <(b, s)>_R)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s Data.Functor.Identity.Identity (a -> b)>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s Data.Functor.Identity.Identity a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
373acfe4413e03be38500e157a202b7c
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cpure ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (a1 :: a) (s1 :: s) -> (a1, s1))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 Trans
                     (<a>_R
                      ->_R <s>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0] <(a, s)>_R))
                     (<a>_R
                      ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <s>_N <Data.Functor.Identity.Identity>_R <a>_N))) -}
5ad49e1edc1b802ed2ff0db6d8d8dbfd
  $s$fApplicativeStateT_$s$fFunctorStateT ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s Data.Functor.Identity.Identity)
                  (Test.Hspec.Discover.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
                     @ s)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               s Data.Functor.Identity.Identity b)
                     (eta1 :: s) ->
                   (x,
                    case (eta
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)
                            eta1)
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(b, s)>_R) of wild { (,) a1 s' ->
                    s' }))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   Trans
                       (<a>_R
                        ->_R <Control.Monad.Trans.State.Lazy.StateT
                                s Data.Functor.Identity.Identity b>_R
                        ->_R <s>_R
                        ->_R Sym (Data.Functor.Identity.N:Identity[0] <(a, s)>_R))
                       (<a>_R
                        ->_R <Control.Monad.Trans.State.Lazy.StateT
                                s Data.Functor.Identity.Identity b>_R
                        ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <s>_N <Data.Functor.Identity.Identity>_R <a>_N))) -}
ccf5beb596c7c7392c9803298a362b03
  $s$fApplicativeStateT_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U(1*U,1*U))><L,U>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f2 :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity a)
                   (s1 :: s) ->
                 let {
                   ds :: Data.Functor.Identity.Identity (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                       s1
                 } in
                 (f2
                    (case ds
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a, s)>_R) of wild { (,) a1 s' ->
                     a1 }),
                  case ds
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(a, s)>_R) of wild { (,) a1 s' ->
                  s' })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0] <(b, s)>_R)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s Data.Functor.Identity.Identity a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
4ba9c37bb2c82d957911f7d32d6d2951
  $tc'C:IsFormatter :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17459327217244446548##
                   18389708936920125078##
                   Test.Hspec.Discover.$trModule
                   Test.Hspec.Discover.$tc'C:IsFormatter2
                   1#
                   Test.Hspec.Discover.$tc'C:IsFormatter1) -}
8649ed5088a098f70f91105d103e6efd
  $tc'C:IsFormatter1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5ac77739ded58508af83c136a7d280ad
  $tc'C:IsFormatter2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Test.Hspec.Discover.$tc'C:IsFormatter3) -}
fc3ff1e8787f8b4081d1e5b3222b8a3f
  $tc'C:IsFormatter3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'C:IsFormatter"#) -}
35c4899cb60e007e07d4cb7150a18d36
  $tcIsFormatter :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10288311593098335090##
                   16294465508237211261##
                   Test.Hspec.Discover.$trModule
                   Test.Hspec.Discover.$tcIsFormatter2
                   0#
                   Test.Hspec.Discover.$tcIsFormatter1) -}
cb6b4d3a8de74086e4861e592e9be7d2
  $tcIsFormatter1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0e31df203e5b235ce9cefb6e6aeb5cd4
  $tcIsFormatter2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   Test.Hspec.Discover.$tcIsFormatter3) -}
6f58696f4f3ccb83e5d797b4f07d975c
  $tcIsFormatter3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("IsFormatter"#) -}
d5628e49fd0187cd56ed5ba19fab506f
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Test.Hspec.Discover.$trModule3
                   Test.Hspec.Discover.$trModule1) -}
9180414f97bed9e5ecef455fe9080450
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Test.Hspec.Discover.$trModule2) -}
e59f57c6c9b237ec8c3b820a5c098519
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Test.Hspec.Discover"#) -}
5595e16e8160ffee1dba96fe0736041c
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Test.Hspec.Discover.$trModule4) -}
bf537a989cc46f44a8e38bd5ff38eace
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("hspec-2.4.8-AD8oV31xXDiFndrFhOZAG"#) -}
1cad1e79e5d260c723aedda4e616bb3f
  type EnumerateM =
    Control.Monad.Trans.State.Lazy.State
      [(GHC.Base.String, GHC.Types.Int)]
    :: * -> *
67c197212c792d0a88a4f6cde81cc919
  class IsFormatter a where
    toFormatter :: a
                   -> GHC.Types.IO Test.Hspec.Core.Formatters.Monad.Formatter
    {-# MINIMAL toFormatter #-}
810f01198047027568172314f9daf5a9
  hspecWithFormatter ::
    Test.Hspec.Discover.IsFormatter a =>
    a -> Test.Hspec.Core.Spec.Monad.Spec -> GHC.Types.IO ()
  {- Arity: 4,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,U)))><L,U><L,C(U(U,U(A,U)))><S,U>,
     Unfolding: InlineRule (0, True, True)
                Test.Hspec.Discover.hspecWithFormatter1
                  `cast`
                (forall (a :: <*>_N).
                 <Test.Hspec.Discover.IsFormatter a>_R
                 ->_R <a>_R
                 ->_R <Test.Hspec.Core.Spec.Monad.Spec>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
b66dd4eda3a94e3842da3c676d90ec01
  hspecWithFormatter1 ::
    Test.Hspec.Discover.IsFormatter a =>
    a
    -> Test.Hspec.Core.Spec.Monad.Spec
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,U)))><L,U><L,C(U(U,U(A,U)))><S,U>,
     Unfolding: (\ @ a
                   ($dIsFormatter :: Test.Hspec.Discover.IsFormatter a)
                   (formatter :: a)
                   (spec :: Test.Hspec.Core.Spec.Monad.Spec)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case ($dIsFormatter
                         `cast`
                       (Test.Hspec.Discover.N:IsFormatter[0] <a>_N)
                         formatter)
                        `cast`
                      (GHC.Types.N:IO[0] <Test.Hspec.Core.Formatters.Monad.Formatter>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case Test.Hspec.Core.Runner.hspec2
                        (Test.Hspec.Core.Options.Config
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           GHC.Types.False
                           (GHC.Base.Nothing @ GHC.IO.FilePath)
                           GHC.Types.False
                           GHC.Types.False
                           (GHC.Base.Nothing @ (Test.Hspec.Core.Util.Path -> GHC.Types.Bool))
                           (GHC.Base.Nothing @ (Test.Hspec.Core.Util.Path -> GHC.Types.Bool))
                           (GHC.Base.Nothing @ GHC.Integer.Type.Integer)
                           (GHC.Base.Nothing @ GHC.Types.Int)
                           (GHC.Base.Nothing @ GHC.Types.Int)
                           (GHC.Base.Nothing @ GHC.Types.Int)
                           Test.Hspec.Core.Example.defaultParams1
                           Test.Hspec.Core.Options.ColorAuto
                           GHC.Types.True
                           (GHC.Base.Just @ Test.Hspec.Core.Formatters.Monad.Formatter ipv1)
                           GHC.Types.False
                           Test.Hspec.Core.Options.defaultConfig1
                           (GHC.Base.Nothing @ GHC.Types.Int))
                        spec
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case ipv3 of wild { Test.Hspec.Core.Runner.Summary ds ds3 ->
                 case ds3 of wild1 { GHC.Types.I# x ->
                 case x of wild2 {
                   DEFAULT -> System.Exit.exitFailure1 @ () ipv2
                   0# -> (# ipv2, GHC.Tuple.() #) } } } } }) -}
4794bc11665d7d6ae2a3e9d62f38fa91
  postProcessSpec ::
    GHC.IO.FilePath
    -> Test.Hspec.Core.Spec.Monad.Spec
    -> Test.Hspec.Core.Spec.Monad.Spec
  {- Arity: 3, Strictness: <L,U><L,1*C1(U(U,1*U(A,1*U)))><S,U>,
     Unfolding: InlineRule (0, True, True)
                Test.Hspec.Discover.postProcessSpec1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <Test.Hspec.Core.Spec.Monad.Spec>_R
                 ->_R Trans
                          (Sym (GHC.Types.N:IO[0]
                                    <((), [Test.Hspec.Core.Tree.SpecTree ()])>_R))
                          (Trans
                               (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                         <[Test.Hspec.Core.Tree.SpecTree ()]>_N
                                         <GHC.Types.IO>_R
                                         <()>_N))
                               (Sym (Test.Hspec.Core.Spec.Monad.N:SpecM[0] <()>_N) <()>_N))) -}
0b8d57d0b216d6c05cbdce039c0407cf
  postProcessSpec1 ::
    GHC.IO.FilePath
    -> Test.Hspec.Core.Spec.Monad.Spec
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ((), [Test.Hspec.Core.Tree.SpecTree ()]) #)
  {- Arity: 3, Strictness: <L,U><L,1*C1(U(U,1*U(A,1*U)))><S,U> -}
instance Test.Hspec.Discover.IsFormatter [Test.Hspec.Core.Formatters.Monad.Formatter]
  = Test.Hspec.Discover.$fIsFormatterFormatter
instance Test.Hspec.Discover.IsFormatter [GHC.Types.IO]
  = Test.Hspec.Discover.$fIsFormatterIO
"SPEC/Test.Hspec.Discover $fApplicativeStateT @ Identity _" [orphan] forall @ s
                                                                            (v1 :: GHC.Base.Monad
                                                                                     Data.Functor.Identity.Identity)
                                                                            (v :: GHC.Base.Functor
                                                                                    Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT @ Data.Functor.Identity.Identity
                                                     @ s
                                                     v
                                                     v1
  = Test.Hspec.Discover.$s$fApplicativeStateT @ s
"SPEC/Test.Hspec.Discover $fApplicativeStateT_$c<*> @ Identity _" [orphan] forall @ s
                                                                                  ($dMonad :: GHC.Base.Monad
                                                                                                Data.Functor.Identity.Identity)
                                                                                  ($dFunctor :: GHC.Base.Functor
                                                                                                  Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ Data.Functor.Identity.Identity
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = Test.Hspec.Discover.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
      @ s
"SPEC/Test.Hspec.Discover $fApplicativeStateT_$cpure @ Identity _" [orphan] forall @ s
                                                                                   ($dMonad :: GHC.Base.Monad
                                                                                                 Data.Functor.Identity.Identity)
                                                                                   ($dFunctor :: GHC.Base.Functor
                                                                                                   Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ Data.Functor.Identity.Identity
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = Test.Hspec.Discover.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
      @ s
"SPEC/Test.Hspec.Discover $fFunctorStateT @ Identity _" [orphan] forall @ s
                                                                        (v :: GHC.Base.Functor
                                                                                Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fFunctorStateT @ Data.Functor.Identity.Identity
                                                 @ s
                                                 v
  = Test.Hspec.Discover.$s$fApplicativeStateT_$s$fFunctorStateT @ s
"SPEC/Test.Hspec.Discover $fFunctorStateT_$cfmap @ Identity _" [orphan] forall @ s
                                                                               ($dFunctor :: GHC.Base.Functor
                                                                                               Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ Data.Functor.Identity.Identity
                                                        @ s
                                                        $dFunctor
  = Test.Hspec.Discover.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
      @ s
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
Warn all {-# WARNING "This module is used by @hspec-discover@.  It is not part of the public API and may change at any time." #-}
trusted: none
require own pkg trusted: False

