module Main where
import Control.Monad (forever)
import Data.Char (toLower)
import Data.Maybe (isJust)
import Data.List (intersperse)
import System.Exit (exitSuccess)
import System.Random (randomRIO)

data Puzzle = Puzzle String [Maybe Char] [Char]
--                    [1]        [2]       [3]
--1. the word we’re trying to guess
--2. the characters we’ve filled in so far
--3. the letters we’ve guessed so far

instance Show Puzzle where
    show (Puzzle _ discovered guessed) =
       (intersperse ' ' $
        fmap renderPuzzleChar discovered)
        ++ " Guessed so far: " ++ guessed

freshPuzzle :: String -> Puzzle
freshPuzzle s = Puzzle s (map (const Nothing) s) []

charInWord :: Puzzle -> Char -> Bool
charInWord (Puzzle s _ _) c = if elem c s then True else False 

alreadyGuessed :: Puzzle -> Char -> Bool
alreadyGuessed (Puzzle _ _ g) c = if elem c g then True else False

renderPuzzleChar :: Maybe Char -> Char
renderPuzzleChar Nothing = '_'
renderPuzzleChar (Just c) = c
-- *Main> fmap renderPuzzleChar [Nothing, Just 'h', Nothing, Just 'e', Nothing]
-- "_h_e_"

type WordList = [String]
allWords :: IO WordList
allWords = do
    dict <- readFile "data/dict.txt"
    return (lines dict)

minWordLength :: Int
minWordLength = 5
maxWordLength :: Int
maxWordLength = 9

gameWords :: IO WordList
gameWords = do
    aw <- allWords
    return (filter gameLength aw)
        where gameLength w =
                let l = length (w :: String)
                in      l >= minWordLength
                    && l < maxWordLength

randomWord :: WordList -> IO String
randomWord wl = do
    randomIndex <- randomRIO (0, (length wl - 1))
    --      fill this part in ^^^
    return $ wl !! randomIndex

randomWord' :: IO String
randomWord' = gameWords >>= randomWord



main :: IO ()
main = do
  putStrLn "hello world"
